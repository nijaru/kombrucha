Project "Kombrucha": A High-Performance Homebrew-Compatible Core in Rust1. Vision & GoalsThis document outlines the technical specification for a next-generation Homebrew-compatible package manager, codenamed "Kombrucha." The primary goal is to drastically improve the performance of core Homebrew operations (install, update, search, etc.) by replacing the Ruby-based command-line interface and internal logic with a compiled, highly concurrent Rust application.A core tenet of this project is pragmatism and compatibility. We will not attempt to rewrite the entire Homebrew ecosystem. Instead, we will strategically replace performance-critical components with Rust while continuing to leverage the vast, existing infrastructure of Homebrew formulae, taps, and the JSON API.Key Goals:Performance: Achieve a significant speed-up over the current Ruby implementation, particularly in dependency resolution, network operations, and JSON parsing.Compatibility: Ensure that all existing Homebrew formulae (.rb files) and taps work without modification.Reliability: Leverage Rust's type system and memory safety to create a more robust and crash-resistant tool.Incremental Adoption: Design a phased rollout that allows for gradual replacement of Homebrew's core functionality.2. Proposed ArchitectureThe fundamental architectural shift is to introduce a Rust binary that acts as the primary bru executable. This binary will handle the user-facing commands and orchestrate the package management process. For compatibility with the existing formula definitions, this Rust core will embed a Ruby interpreter to evaluate the Formula DSL.+------------------------------------------------------+
|                  User (Terminal)                     |
|                        |                             |
|                  bru <command>                       |
+------------------------|-----------------------------+
                         |
+------------------------V-----------------------------+
|        Rust Core Application (`kombrucha`)           |
|                                                      |
|   +----------------------------------------------+   |
|   |  CLI Parsing & Command Dispatch (e.g., clap) |   |
|   +----------------------------------------------+   |
|   |  Concurrent Operations Manager (e.g., Tokio) |   |
|   +----------------------------------------------+   |
|   |  Dependency Resolution Engine (Rust)         |   |
|   +----------------------------------------------+   |
|   |  JSON API Client & Parser (e.g., reqwest,    |   |
|   |  serde)                                      |   |
|   +----------------------------------------------+   |
|   |  Bottle (Binary Package) Manager (Rust)      |   |
|   +----------------------------------------------+   |
|   |          Ruby Interop Layer (magnus)         |   |
|   |                        |                       |   |
|   |  +---------------------V-------------------+   |   |
|   |  |   Embedded Ruby Interpreter (libruby)   |   |   |
|   |  |                                         |   |   |
|   |  |  - Executes Formula DSL (`.rb` files)   |   |   |
|   |  |  - Provides install logic              |   |   |
|   |  +-----------------------------------------+   |   |
|   +----------------------------------------------+   |
+------------------------|-----------------------------+
                         |
+------------------------V-----------------------------+
|         Existing Homebrew Infrastructure             |
|                                                      |
|   +-----------------+   +------------------------+   |
|   |  Formulae/Taps  |   |   Homebrew JSON API    |   |
|   | (Git Repos)     |   | (formulae.brew.sh)     |   |
|   +-----------------+   +------------------------+   |
|   +-----------------+   +------------------------+   |
|   | Bottles (Binary |   |   Source Code Tarballs |   |
|   | Packages on GH) |   |    (from upstreams)    |   |
|   +-----------------+   +------------------------+   |
+------------------------------------------------------+
Workflow Example (bru install <formula>):The user runs bru install wget. The kombrucha binary is executed.The Rust CLI parser identifies the install command and the wget argument.The Rust core queries the Homebrew JSON API for wget's metadata, including its dependencies.The Rust dependency resolution engine recursively fetches metadata for all dependencies, building a dependency graph in parallel.For each formula in the graph, the Rust core:Checks if a pre-compiled "bottle" is available for the user's OS.If a bottle exists, the Rust Bottle Manager downloads and extracts the gzipped tarball in parallel with other downloads.If no bottle exists, the Rust core uses the Ruby Interop Layer to invoke the embedded Ruby interpreter.The Ruby interpreter loads the corresponding .rb formula file and executes the install method. This method contains the logic for downloading the source code and running make, cmake, etc.The Rust core manages the installation process, ensuring that dependencies are installed in the correct order.3. Component Breakdown3.1. Rust Core (The "Kombrucha" Binary)This is the heart of the new system and will be written entirely in Rust.CLI: A user-friendly and fast command-line interface built using a library like clap. It will parse all bru commands and their arguments.JSON API Client: An efficient, asynchronous HTTP client (using reqwest) to interact with formulae.brew.sh. All JSON responses will be deserialized into strongly-typed Rust structs using serde for maximum safety and performance.Dependency Resolver: A custom-built, parallel dependency resolution engine. It will build the complete dependency tree by concurrently fetching and parsing JSON metadata.Bottle Manager: A component responsible for downloading, verifying checksums, and extracting the gzipped tarballs (.tar.gz) that constitute Homebrew bottles. This will be highly parallelized.Ruby Interop Layer: A crucial component that will use a library like magnus to safely embed and interact with a Ruby interpreter. This layer will be responsible for:Loading and executing the Ruby code within formula files.Calling specific methods within the Formula DSL (e.g., the install block).Translating data between the Rust and Ruby runtimes.3.2. Ruby/Homebrew Infrastructure (Leveraged, Not Replaced)We will continue to rely on the vast and mature Homebrew infrastructure:Formulae as a DSL: All existing *.rb files that define packages will remain in Ruby. There is no plan to translate these into a different format, as that would be an enormous and unnecessary undertaking. The kombrucha binary will execute this Ruby code.Taps: The system of third-party repositories (taps) will continue to function as-is. kombrucha will be able to add, remove, and update taps by interacting with their Git repositories.Homebrew JSON API: This will be the primary source of truth for formula and cask metadata, replacing the need to parse Ruby files for dependency information in most cases.Bottles: We will continue to consume the pre-compiled binary packages (bottles) generated by the official Homebrew infrastructure.4. Implementation Plan: A Phased ApproachA phased rollout is crucial to ensure stability and allow for iterative development.Phase 1: Read-Only Commands and Dependency ResolutionImplement the Rust CLI for commands that don't modify the system: search, info, deps, uses.Build the core dependency resolution engine that uses the JSON API.The kombrucha binary at this stage can be used as a faster alternative for information-gathering commands.Phase 2: Bottle-Based InstallationImplement the Bottle Manager in Rust.Implement the install command, but only for formulae that have bottles available.At this stage, kombrucha can handle the majority of common package installations, offering a significant speed boost.Phase 3: Ruby Interop for Source BuildsIntegrate the Ruby Interop Layer using magnus.Enhance the install command to fall back to a source build (by executing the formula's install method via the embedded Ruby interpreter) if a bottle is not available.Implement the uninstall and upgrade commands, which will also require Ruby interop to run pre- and post-install hooks defined in the formulae.Phase 4: Full Command CompatibilityImplement the remaining bru commands (doctor, tap, bundle, etc.), progressively replacing all user-facing functionality of the original brew script.At the end of this phase, kombrucha can serve as a complete, drop-in replacement for the standard Homebrew executable.5. Recommended Tooling (Rust Crates)CLI: clap - A powerful and feature-rich command-line argument parser.Ruby Interop: magnus - Offers a high-level, safe, and ergonomic API for embedding Ruby in Rust.Async Runtime: tokio - The de-facto standard for asynchronous programming in Rust, essential for concurrent network and file operations.HTTP Client: reqwest - A convenient and powerful asynchronous HTTP client.JSON Serialization/Deserialization: serde and serde_json - The standard for fast and reliable JSON handling in Rust.Tarball/Gzip Handling: tar and flate2 - For efficiently extracting bottle contents.By following this specification, we can create a Homebrew-compatible tool that leverages the performance and safety of Rust while respecting and integrating with the vast, existing Homebrew ecosystem.
